#!/usr/bin/env ruby

require_relative '../rubee.rb'

Rubee::Autoload.call
ENV['RACK_ENV'] ||= 'development'

command, file_name = ARGV.first&.split(':')


def ensure_database_exists(db_url)
  uri = URI.parse(db_url)
  case uri.scheme
  when "sqlite"
    begin
      Sequel.connect(db_url)
      puts "Database #{ENV['RACK_ENV']} exists"
    rescue => _
      if File.exist?(db_path = db_url.sub(/^sqlite:\/\//, ''))
        puts "Database #{ENV['RACK_ENV']} exists"
      else
        Sequel.sqlite(db_path)
        puts "Database #{ENV['RACK_ENV']} created"
      end
    end
  when "postgres"
    begin
      Sequel.connect(db_url)
      puts "Database #{ENV['RACK_ENV']} exists"
    rescue => _
      con = Sequel.connect(Rubee::Configuration.get_database_url.gsub(/(\/test|\/development|\/production)/, ''))
      con.run("CREATE DATABASE #{ENV['RACK_ENV']}")
      puts "Database #{ENV['RACK_ENV']} created"
    end
  else
    puts "Unsupported database type: #{db_url}"
  end
end


if command == 'run'
  Object.const_get(file_name.split('_').map(&:capitalize).join).new.call
  puts "Migration #{file_name} completed"
  puts "Regenerate schema file"
elsif command == 'init'
  ensure_database_exists(Rubee::Configuration.get_database_url)
elsif command == 'structure'
  schema_hash = {}

  SequelObject::DB.tables.each do |table|
    schema_hash[table] = {}

    SequelObject::DB.schema(table).each do |column, details|
      schema_hash[table][column] = details
    end
  end
  formatted_hash = JSON.pretty_generate(schema_hash)
                       .gsub(/\"(\w+)\":/, '\1:')  # Convert keys to symbols
                       .gsub(': null', ': nil')   # Convert `null` to `nil`

  File.open("db/#{ENV['RACK_ENV']}_structure.rb", 'w') do |file|
    file.puts "#{ENV['RACK_ENV'].upcase}_STRUCTURE = #{formatted_hash}"
  end

  puts "db/#{ENV['RACK_ENV']}_structure.rb updated"
else
  puts "Unknown command: #{command}"
end
